<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polygons · DeviceLayout.jl</title><meta name="title" content="Polygons · DeviceLayout.jl"/><meta property="og:title" content="Polygons · DeviceLayout.jl"/><meta property="twitter:title" content="Polygons · DeviceLayout.jl"/><meta name="description" content="Documentation for DeviceLayout.jl."/><meta property="og:description" content="Documentation for DeviceLayout.jl."/><meta property="twitter:description" content="Documentation for DeviceLayout.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DeviceLayout.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Geometry-Level Layout</span><ul><li><a class="tocitem" href="../geometrylevel/">Overview</a></li><li><a class="tocitem" href="../units/">Units</a></li><li><a class="tocitem" href="../points/">Points</a></li><li><a class="tocitem" href="../geometry/">Geometry</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../entitystyles/">Entity Styles</a></li><li class="is-active"><a class="tocitem" href>Polygons</a><ul class="internal"><li><a class="tocitem" href="#Abstract-polygons"><span>Abstract polygons</span></a></li><li><a class="tocitem" href="#Clipping"><span>Clipping</span></a></li><li><a class="tocitem" href="#Styles"><span>Styles</span></a></li><li><a class="tocitem" href="#Offsetting"><span>Offsetting</span></a></li><li><a class="tocitem" href="#Rectangle-API"><span>Rectangle API</span></a></li><li><a class="tocitem" href="#Polygon-API"><span>Polygon API</span></a></li></ul></li><li><a class="tocitem" href="../coordinate_systems/">Coordinate Systems</a></li><li><a class="tocitem" href="../texts/">Texts</a></li><li><a class="tocitem" href="../paths/">Paths</a></li><li><a class="tocitem" href="../routes/">Routes</a></li><li><a class="tocitem" href="../shapes/">Shape library</a></li><li><a class="tocitem" href="../autofill/">Autofill</a></li><li><a class="tocitem" href="../render/">Rendering</a></li><li><a class="tocitem" href="../solidmodels/">Solid Models (3D Geometry)</a></li><li><a class="tocitem" href="../fileio/">File Formats</a></li><li><a class="tocitem" href="../faq/">Troubleshooting/FAQ</a></li></ul></li><li><span class="tocitem">Schematic-Driven Layout</span><ul><li><a class="tocitem" href="../schematicdriven/">Overview</a></li><li><a class="tocitem" href="../schematicdriven/components/">Components</a></li><li><a class="tocitem" href="../schematicdriven/hooks/">Hooks</a></li><li><a class="tocitem" href="../schematicdriven/schematics/">Schematics</a></li><li><a class="tocitem" href="../schematicdriven/technologies/">Technologies</a></li><li><a class="tocitem" href="../schematicdriven/targets/">Targets</a></li><li><a class="tocitem" href="../schematicdriven/solidmodels/">Solid Models</a></li><li><a class="tocitem" href="../schematicdriven/pdks/">PDKs</a></li><li><a class="tocitem" href="../schematicdriven/styleguide/">Style Guide</a></li><li><a class="tocitem" href="../schematicdriven/faq/">Troubleshooting/FAQ</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/examplepdk/">ExamplePDK</a></li><li><a class="tocitem" href="../examples/qpu17/">Quantum Processor</a></li><li><a class="tocitem" href="../examples/singletransmon/">Single-Transmon Simulation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Geometry-Level Layout</a></li><li class="is-active"><a href>Polygons</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polygons</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aws-cqc/DeviceLayout.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/main/docs/src/polygons.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Abstract-polygons"><a class="docs-heading-anchor" href="#Abstract-polygons">Abstract polygons</a><a id="Abstract-polygons-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-polygons" title="Permalink"></a></h2><p>In this package, any polygon regardless of its concrete representation in memory should be a subtype of <a href="#DeviceLayout.AbstractPolygon"><code>DeviceLayout.AbstractPolygon</code></a>. Usually, when we write &quot;polygon&quot; in unformatted text, we mean <code>AbstractPolygon</code>. (In this documentation, we try to follow this pattern for common words and corresponding abstract types. For example, we&#39;ll use &quot;coordinate system&quot; to mean any <code>AbstractCoordinateSystem</code> including <code>Cell</code>, not necessarily just <code>CoordinateSystem</code>.)</p><article><details class="docstring" open="true"><summary id="DeviceLayout.AbstractPolygon"><a class="docstring-binding" href="#DeviceLayout.AbstractPolygon"><code>DeviceLayout.AbstractPolygon</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type AbstractPolygon{T} &lt;: GeometryEntity{T} end</code></pre><p>Anything you could call a polygon regardless of the underlying representation. Currently only <code>Rectangle</code>, <code>Polygon</code>, and <code>ClippedPolygon</code> are concrete subtypes, but one could imagine further subtypes to represent specific shapes that appear in highly optimized pattern formats. Examples include the OASIS format (which has 25 implementations of trapezoids) or e-beam lithography pattern files like the Raith GPF format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/DeviceLayout.jl#L348-L357">source</a></section></details></article><p>The most important polygon subtype is <a href="#DeviceLayout.Polygons.Polygon"><code>Polygon</code></a>, which is defined by a vector of points. <code>Polygon</code> is the primitive entity type for <code>Cell</code>—any shape being rendered to a <code>Cell</code> must end up represented as one or more <code>Polygon</code>s. The <code>GeometryEntity</code> interface provides a <code>to_polygons</code> function that produces that representation.</p><p>Most functions in the geometry interface (besides transformation, which must be implemented by subtypes) will fall back to calling <code>to_polygons</code> on entities first if there is no specialized method. For example, if you ask for the bounding box of a path node (which could define a shape like multiple parallel brushstrokes) <code>bounds(node)</code> will simply find the bounding box of the polygon(s) from <code>to_polygons(node)</code>, using the default tolerance for discretization of curves.</p><h2 id="Clipping"><a class="docs-heading-anchor" href="#Clipping">Clipping</a><a id="Clipping-1"></a><a class="docs-heading-anchor-permalink" href="#Clipping" title="Permalink"></a></h2><p>Geometric Boolean operations on polygons are called &quot;clipping&quot; operations. For 2D geometry, these—<code>union2d</code>, <code>difference2d</code>, <code>intersection2d</code>, and <code>xor2d</code>—are the only geometric Booleans available. Other geometry types are first converted to polygons using <code>to_polygons</code> to perform clipping.</p><div class="admonition is-info" id="Info-428d57e07356330b"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-428d57e07356330b" title="Permalink"></a></header><div class="admonition-body"><p>Boolean operations in 3D with <code>SolidModel</code> are handled by the Open CASCADE Technology kernel, which works directly with rich geometry types rendered from our native <code>CoordinateSystem</code>.</p></div></div><p>For many use cases, <code>union2d</code>, <code>difference2d</code>, and <code>intersect2d</code> behave as expected and are easiest to use. More general operations may be accomplished using the <code>clip</code> function.</p><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.union2d"><a class="docstring-binding" href="#DeviceLayout.Polygons.union2d"><code>DeviceLayout.Polygons.union2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">union2d(p1, p2)</code></pre><p>Return the geometric union of p1 and p2 as a <code>ClippedPolygon</code>.</p><p>Each of <code>p1</code> and <code>p2</code> may be a <code>GeometryEntity</code> or array of <code>GeometryEntity</code>. All entities are first converted to polygons using <a href="../geometry/#DeviceLayout.to_polygons"><code>to_polygons</code></a>.</p><p>Each of <code>p1</code> and <code>p2</code> can also be a <code>GeometryStructure</code> or <code>GeometryReference</code>, in which case <code>elements(flatten(p))</code> will be converted to polygons.</p><p>Each can also be a pair <code>geom =&gt; layer</code>, where <code>geom</code> is a <code>GeometryStructure</code> or <code>GeometryReference</code>, while <code>layer</code> is a <code>DeviceLayout.Meta</code>, a layer name <code>Symbol</code>, and/or a collection of either, in which case only the elements in those layers will used.</p><p>This is not implemented as a method of <code>union</code> because you can have a set union of arrays of polygons, which is a distinct operation.</p><p>The Clipper polyfill rule is PolyFillTypePositive, meaning as long as a region lies within more non-hole (by orientation) than hole polygons, it lies in the union.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1098-L1119">source</a></section><section><div><pre><code class="language-julia hljs">union2d(p)</code></pre><p>Return the geometric union of <code>p</code> or all entities in <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1130-L1134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.difference2d"><a class="docstring-binding" href="#DeviceLayout.Polygons.difference2d"><code>DeviceLayout.Polygons.difference2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">difference2d(p1, p2)</code></pre><p>Return the geometric union of <code>p1</code> minus the geometric union of <code>p2</code> as a <code>ClippedPolygon</code>.</p><p>Each of <code>p1</code> and <code>p2</code> may be a <code>GeometryEntity</code> or array of <code>GeometryEntity</code>. All entities are first converted to polygons using <a href="../geometry/#DeviceLayout.to_polygons"><code>to_polygons</code></a>.</p><p>Each of <code>p1</code> and <code>p2</code> can also be a <code>GeometryStructure</code> or <code>GeometryReference</code>, in which case <code>elements(flatten(p))</code> will be converted to polygons.</p><p>Each can also be a pair <code>geom =&gt; layer</code>, where <code>geom</code> is a <code>GeometryStructure</code> or <code>GeometryReference</code>, while <code>layer</code> is a <code>DeviceLayout.Meta</code>, a layer name <code>Symbol</code>, and/or a collection of either, in which case only the elements in those layers will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1138-L1152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.intersect2d"><a class="docstring-binding" href="#DeviceLayout.Polygons.intersect2d"><code>DeviceLayout.Polygons.intersect2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">intersect2d(p1, p2)</code></pre><p>Return the geometric union of <code>p1</code> intersected with the geometric union of <code>p2</code>  as a <code>ClippedPolygon</code>.</p><p>Each of <code>p1</code> and <code>p2</code> may be a <code>GeometryEntity</code> or array of <code>GeometryEntity</code>. All entities are first converted to polygons using <a href="../geometry/#DeviceLayout.to_polygons"><code>to_polygons</code></a>.</p><p>Each of <code>p1</code> and <code>p2</code> can also be a <code>GeometryStructure</code> or <code>GeometryReference</code>, in which case <code>elements(flatten(p))</code> will be converted to polygons.</p><p>Each can also be a pair <code>geom =&gt; layer</code>, where <code>geom</code> is a <code>GeometryStructure</code> or <code>GeometryReference</code>, while <code>layer</code> is a <code>DeviceLayout.Meta</code>, a layer name <code>Symbol</code>, and/or a collection of either, in which case only the elements in those layers will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1163-L1177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.xor2d"><a class="docstring-binding" href="#DeviceLayout.Polygons.xor2d"><code>DeviceLayout.Polygons.xor2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">xor2d(p1, p2)</code></pre><p>Return the symmetric difference (XOR) of <code>p1</code> and <code>p2</code> as a <code>ClippedPolygon</code>.</p><p>The XOR operation returns regions that are in either <code>p1</code> or <code>p2</code>, but not in both. This is useful for finding non-overlapping regions between two sets of polygons.</p><p>Each of <code>p1</code> and <code>p2</code> may be a <code>GeometryEntity</code> or array of <code>GeometryEntity</code>. All entities are first converted to polygons using <a href="../geometry/#DeviceLayout.to_polygons"><code>to_polygons</code></a>.</p><p>Each of <code>p1</code> and <code>p2</code> can also be a <code>GeometryStructure</code> or <code>GeometryReference</code>, in which case <code>elements(flatten(p))</code> will be converted to polygons.</p><p>Each can also be a pair <code>geom =&gt; layer</code>, where <code>geom</code> is a <code>GeometryStructure</code> or <code>GeometryReference</code>, while <code>layer</code> is a <code>DeviceLayout.Meta</code>, a layer name <code>Symbol</code>, and/or a collection of either, in which case only the elements in those layers will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1188-L1205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.clip"><a class="docstring-binding" href="#DeviceLayout.Polygons.clip"><code>DeviceLayout.Polygons.clip</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clip(op::Clipper.ClipType, s, c; kwargs...) where {S&lt;:Coordinate, T&lt;:Coordinate}
clip(op::Clipper.ClipType, s::AbstractVector{A}, c::AbstractVector{B};
    kwargs...) where {S, T, A&lt;:Polygon{S}, B&lt;:Polygon{T}}
clip(op::Clipper.ClipType,
    s::AbstractVector{Polygon{T}}, c::AbstractVector{Polygon{T}};
    pfs::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd,
    pfc::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd) where {T}</code></pre><p>Return the <code>ClippedPolygon</code> resulting from a polygon clipping operation.</p><p>Uses the <a href="http://www.angusj.com/delphi/clipper.php"><code>Clipper</code></a> library and the <a href="https://github.com/Voxel8/Clipper.jl"><code>Clipper.jl</code></a> wrapper to perform polygon clipping.</p><p><strong>Positional arguments</strong></p><p>The first argument must be one of the following types to specify a clipping operation:</p><ul><li><code>Clipper.ClipTypeDifference</code></li><li><code>Clipper.ClipTypeIntersection</code></li><li><code>Clipper.ClipTypeUnion</code></li><li><code>Clipper.ClipTypeXor</code></li></ul><p>Note that these are types; you should not follow them with <code>()</code>.</p><p>The second and third argument may be a <code>GeometryEntity</code> or array of <code>GeometryEntity</code>. All entities are first converted to polygons using <a href="../geometry/#DeviceLayout.to_polygons"><code>to_polygons</code></a>. Each can also be a <code>GeometryStructure</code> or <code>GeometryReference</code>, in which case <code>elements(flatten(p))</code> will be converted to polygons. Each can also be a pair <code>geom =&gt; layer</code>, where <code>geom</code> is a <code>GeometryStructure</code> or <code>GeometryReference</code>, while <code>layer</code> is a <code>DeviceLayout.Meta</code>, a layer name <code>Symbol</code>, and/or a collection of either, in which case only the elements in those layers will be taken from the flattened structure.</p><p><strong>Keyword arguments</strong></p><p><code>pfs</code> and <code>pfc</code> specify polygon fill rules for the <code>s</code> and <code>c</code> arguments, respectively. These arguments may include:</p><ul><li><code>Clipper.PolyFillTypeNegative</code></li><li><code>Clipper.PolyFillTypePositive</code></li><li><code>Clipper.PolyFillTypeEvenOdd</code></li><li><code>Clipper.PolyFillTypeNonZero</code></li></ul><p>See the <a href="http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/PolyFillType.htm"><code>Clipper</code> docs</a> for further information.</p><p>See also <a href="#DeviceLayout.Polygons.union2d">union2d</a>, <a href="#DeviceLayout.Polygons.difference2d">difference2d</a>, and <a href="#DeviceLayout.Polygons.intersect2d">intersect2d</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L924-L971">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.cliptree"><a class="docstring-binding" href="#DeviceLayout.Polygons.cliptree"><code>DeviceLayout.Polygons.cliptree</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cliptree(op::Clipper.ClipType, s::AbstractPolygon{S}, c::AbstractPolygon{T};
    kwargs...) where {S&lt;:Coordinate, T&lt;:Coordinate}
cliptree(op::Clipper.ClipType, s::AbstractVector{A}, c::AbstractVector{B};
    kwargs...) where {S, T, A&lt;:AbstractPolygon{S}, B&lt;:AbstractPolygon{T}}
cliptree(op::Clipper.ClipType,
    s::AbstractVector{Polygon{T}}, c::AbstractVector{Polygon{T}};
    pfs::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd,
    pfc::Clipper.PolyFillType=Clipper.PolyFillTypeEvenOdd) where {T}</code></pre><p>Return a <code>Clipper.PolyNode</code> representing parent-child relationships between polygons and interior holes. The units and number type may need to be converted.</p><p>Uses the <a href="http://www.angusj.com/delphi/clipper.php"><code>Clipper</code></a> library and the <a href="https://github.com/Voxel8/Clipper.jl"><code>Clipper.jl</code></a> wrapper to perform polygon clipping.</p><p><strong>Positional arguments</strong></p><p>The first argument must be one of the following types to specify a clipping operation:</p><ul><li><code>Clipper.ClipTypeDifference</code></li><li><code>Clipper.ClipTypeIntersection</code></li><li><code>Clipper.ClipTypeUnion</code></li><li><code>Clipper.ClipTypeXor</code></li></ul><p>Note that these are types; you should not follow them with <code>()</code>. The second and third arguments are <code>AbstractPolygon</code>s or vectors thereof.</p><p><strong>Keyword arguments</strong></p><p><code>pfs</code> and <code>pfc</code> specify polygon fill rules for the <code>s</code> and <code>c</code> arguments, respectively. These arguments may include:</p><ul><li><code>Clipper.PolyFillTypeNegative</code></li><li><code>Clipper.PolyFillTypePositive</code></li><li><code>Clipper.PolyFillTypeEvenOdd</code></li><li><code>Clipper.PolyFillTypeNonZero</code></li></ul><p>See the <a href="http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/PolyFillType.htm"><code>Clipper</code> docs</a> for further information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1018-L1058">source</a></section></details></article><p>The results of clipping are represented using the <code>ClippedPolygon &lt;: AbstractPolygon</code> type, which stores a tree of positive and negative contours. These mainly exist to represent polygons with holes without having to generate &quot;keyhole&quot; polygons as required by the GDSII format. This ends up being convenient for other backends that don&#39;t want keyhole polygons as well as for applying different styles to different boundary or hole contours.</p><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.ClippedPolygon"><a class="docstring-binding" href="#DeviceLayout.Polygons.ClippedPolygon"><code>DeviceLayout.Polygons.ClippedPolygon</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ClippedPolygon{T} &lt;: AbstractPolygon{T}
    tree::Clipper.PolyNode{Point{T}}
end</code></pre><p>Collection of polygons defined by a call to Clipper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L283-L289">source</a></section></details></article><h2 id="Styles"><a class="docs-heading-anchor" href="#Styles">Styles</a><a id="Styles-1"></a><a class="docs-heading-anchor-permalink" href="#Styles" title="Permalink"></a></h2><p>In addition to other generic <a href="../entitystyles/">entity styles</a> like <code>NoRender</code>, <code>AbstractPolygon</code>s can be paired with the <code>Rounded</code> style. <code>ClippedPolygon</code>s support <code>StyleDict</code>, which allows for different styles to be applied to different contours in its tree.</p><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.Rounded"><a class="docstring-binding" href="#DeviceLayout.Polygons.Rounded"><code>DeviceLayout.Polygons.Rounded</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Rounded{T &lt;: Coordinate} &lt;: GeometryEntityStyle
    abs_r::T = zero(T)
    rel_r::Float64 = 0.0
    min_side_len::T = r
    min_angle::Float64 = 1e-3
    p0::Vector{Point{T}} = []
    inverse_selection::Bool = false
end</code></pre><p>Rounded polygon style defined by either radius absolute radius <code>abs_r</code> or relative radius <code>rel_r</code>. Only one of <code>abs_r</code> or <code>rel_r</code> can be non-zero at once. Can&#39;t handle shapes with interior cuts, or shapes with too sharp of angles relative to segment length. If <code>rel_r</code> is non-zero the radius of curvature at each vertex is calculated with <code>rel_r * min(l₁, l₂)</code> where <code>l₁</code> and <code>l₂</code> denote the length of the two attached line segments.</p><p>Example usage:</p><pre><code class="language-julia hljs">r = Rectangle(10μm, 10μm)
rsty = Rounded(1μm)
# Create a rounded rectangle StyledEntity with different options for syntax
rounded_rect = rsty(r)
rounded_rect = styled(r, rsty)
rounded_rect = Rounded(r, 1μm)
# Turn the result into a plain Polygon
rounded_rect_discretized_poly = to_polygons(rounded_rect)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>min_side_len</code>: The minimum side length that will get rounded (e.g. for 90-degree angles, it makes sense to have <code>min_side_len = 2 * rounding_radius</code>). This currently uses exact comparison, so it may result in very short straight edges or failure to round a corner due to floating point imprecision.</li><li><code>min_angle</code>: If adjacent sides are collinear within the tolerance set by <code>min_angle</code>, rounding will not be performed.</li><li><code>p0</code>: set of target points used to select vertices to attempt to round when applied to a polygon. Selected vertices where <code>min_side_len</code> and <code>min_angle</code> are satisfied will be rounded. If empty, all vertices will be selected. Otherwise, for each point in <code>p0</code>, the nearest point that satisfies <code>selection_tolerance</code> in the styled polygon will be selected. Note that for a <code>ClippedPolygon</code>, the same <code>p0</code> will be used for every contour; for different rounding styles on different contours, use <code>StyleDict</code>.</li><li><code>inverse_selection</code>: If true, the selection from <code>p0</code> is inverted; that is, all corners will be rounded except those selected by <code>p0</code>.</li><li><code>selection_tolerance</code>: Selections using <code>p0</code> will only be chosen if they are within <code>selection_tolerance</code> distance of <code>p0</code>. The current default of infinite reflects the legacy behaviour of always finding the closest point, and will be replaced with a small non-zero tolerance to capture floating point precision in future (approximately 1.0nm).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L541-L591">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.StyleDict"><a class="docstring-binding" href="#DeviceLayout.Polygons.StyleDict"><code>DeviceLayout.Polygons.StyleDict</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct StyleDict{S} &lt;: GeometryEntityStyle where {S}
    styles::Dict{Vector{Int}, GeometryEntityStyle},
    default::S
end</code></pre><p>Style used for applying differing styles to different Polygons at different levels within a <code>ClippedPolygon</code> or <code>CurvilinearRegion</code>. Styles are stored by the sequence of child indices required to find the corresponding <code>Clipper.PolyNode</code> within the <code>ClippedPolygon</code>. For a <code>CurvilinearRegion</code> only dictionaries of depth 2 (a single parent and one set of holes) are valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L2190-L2200">source</a></section></details></article><h2 id="Offsetting"><a class="docs-heading-anchor" href="#Offsetting">Offsetting</a><a id="Offsetting-1"></a><a class="docs-heading-anchor-permalink" href="#Offsetting" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DeviceLayout.offset"><a class="docstring-binding" href="#DeviceLayout.offset"><code>DeviceLayout.offset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">offset{S&lt;:Coordinate}(s::AbstractPolygon{S}, delta::Coordinate;
    j::Clipper.JoinType=Clipper.JoinTypeMiter,
    e::Clipper.EndType=Clipper.EndTypeClosedPolygon)
offset{S&lt;:AbstractPolygon}(subject::AbstractVector{S}, delta::Coordinate;
    j::Clipper.JoinType=Clipper.JoinTypeMiter,
    e::Clipper.EndType=Clipper.EndTypeClosedPolygon)
offset{S&lt;:Polygon}(s::AbstractVector{S}, delta::Coordinate;
    j::Clipper.JoinType=Clipper.JoinTypeMiter,
    e::Clipper.EndType=Clipper.EndTypeClosedPolygon)</code></pre><p>Using the <a href="http://www.angusj.com/delphi/clipper.php"><code>Clipper</code></a> library and the <a href="https://github.com/Voxel8/Clipper.jl"><code>Clipper.jl</code></a> wrapper, perform polygon offsetting.</p><p>The orientations of polygons must be consistent, such that outer polygons share the same orientation, and any holes have the opposite orientation. Additionally, any holes should be contained within outer polygons; offsetting hole edges may create positive artifacts at corners.</p><p>The first argument should be an <a href="#DeviceLayout.AbstractPolygon"><code>AbstractPolygon</code></a>. The second argument is how much to offset the polygon. Keyword arguments include a <a href="http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/JoinType.htm">join type</a>:</p><ul><li><code>Clipper.JoinTypeMiter</code></li><li><code>Clipper.JoinTypeRound</code></li><li><code>Clipper.JoinTypeSquare</code></li></ul><p>and also an <a href="http://www.angusj.com/delphi/clipper/documentation/Docs/Units/ClipperLib/Types/EndType.htm">end type</a>:</p><ul><li><code>Clipper.EndTypeClosedPolygon</code></li><li><code>Clipper.EndTypeClosedLine</code></li><li><code>Clipper.EndTypeOpenSquare</code></li><li><code>Clipper.EndTypeOpenRound</code></li><li><code>Clipper.EndTypeOpenButt</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1416-L1452">source</a></section></details></article><h2 id="Rectangle-API"><a class="docs-heading-anchor" href="#Rectangle-API">Rectangle API</a><a id="Rectangle-API-1"></a><a class="docs-heading-anchor-permalink" href="#Rectangle-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DeviceLayout.Rectangles.Rectangle"><a class="docstring-binding" href="#DeviceLayout.Rectangles.Rectangle"><code>DeviceLayout.Rectangles.Rectangle</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Rectangle{T} &lt;: AbstractPolygon{T}
    ll::Point{T}
    ur::Point{T}
    function Rectangle(a,b)
        # Ensure ll is lower-left, ur is upper-right.
        ll = Point(a.&lt;=b) .* a + Point(b.&lt;=a) .* b
        ur = Point(a.&lt;=b) .* b + Point(b.&lt;=a) .* a
        new(ll,ur)
    end
end</code></pre><p>A rectangle, defined by opposing lower-left and upper-right corner coordinates. Lower-left and upper-right are guaranteed to be such by the inner constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L16-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Rectangles.Rectangle-Tuple{Point, Point}"><a class="docstring-binding" href="#DeviceLayout.Rectangles.Rectangle-Tuple{Point, Point}"><code>DeviceLayout.Rectangles.Rectangle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rectangle(ll::Point, ur::Point)</code></pre><p>Convenience constructor for <code>Rectangle</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L42-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Rectangles.Rectangle-Tuple{Any, Any}"><a class="docstring-binding" href="#DeviceLayout.Rectangles.Rectangle-Tuple{Any, Any}"><code>DeviceLayout.Rectangles.Rectangle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rectangle(width, height)</code></pre><p>Constructs <code>Rectangle</code> objects by specifying the width and height rather than the lower-left and upper-right corners.</p><p>The rectangle will sit with the lower-left corner at the origin. With centered rectangles we would need to divide width and height by 2 to properly position. If we wanted an object of <code>Rectangle{Int}</code> type, this would not be possible if either <code>width</code> or <code>height</code> were odd numbers. This definition ensures type stability in the constructor.</p><p><code>Rectangle</code> has the special importance of being the return type of <code>bounds</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L50-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.bounds-Tuple{Rectangle}"><a class="docstring-binding" href="#DeviceLayout.bounds-Tuple{Rectangle}"><code>DeviceLayout.bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bounds(r::Rectangle)</code></pre><p>No-op (just returns <code>r</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L100-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Rectangles.height-Tuple{Rectangle}"><a class="docstring-binding" href="#DeviceLayout.Rectangles.height-Tuple{Rectangle}"><code>DeviceLayout.Rectangles.height</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">height(r::Rectangle)</code></pre><p>Return the height of a rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L84-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Rectangles.isproper-Tuple{Rectangle}"><a class="docstring-binding" href="#DeviceLayout.Rectangles.isproper-Tuple{Rectangle}"><code>DeviceLayout.Rectangles.isproper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isproper(r::Rectangle)</code></pre><p>Return <code>true</code> if the rectangle has a non-zero area. Otherwise, returns <code>false</code>. Note that the upper-right and lower-left corners are enforced to be the <code>ur</code> and <code>ll</code> fields of a <code>Rectangle</code> by the inner constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L91-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Points.lowerleft-Tuple{Rectangle}"><a class="docstring-binding" href="#DeviceLayout.Points.lowerleft-Tuple{Rectangle}"><code>DeviceLayout.Points.lowerleft</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lowerleft(r::Rectangle)</code></pre><p>Return the lower-left corner of a rectangle (Point object).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L107-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Points.upperright-Tuple{Rectangle}"><a class="docstring-binding" href="#DeviceLayout.Points.upperright-Tuple{Rectangle}"><code>DeviceLayout.Points.upperright</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">upperright(r::Rectangle)</code></pre><p>Return the upper-right corner of a rectangle (Point object).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L114-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.points-Union{Tuple{Rectangle{T}}, Tuple{T}} where T&lt;:Real"><a class="docstring-binding" href="#DeviceLayout.Polygons.points-Union{Tuple{Rectangle{T}}, Tuple{T}} where T&lt;:Real"><code>DeviceLayout.Polygons.points</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">points{T}(x::Rectangle{T})</code></pre><p>Return the array of <code>Point</code> objects defining the rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L392-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Rectangles.width-Tuple{Rectangle}"><a class="docstring-binding" href="#DeviceLayout.Rectangles.width-Tuple{Rectangle}"><code>DeviceLayout.Rectangles.width</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">width(r::Rectangle)</code></pre><p>Return the width of a rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/rectangles.jl#L77-L81">source</a></section></details></article><h2 id="Polygon-API"><a class="docs-heading-anchor" href="#Polygon-API">Polygon API</a><a id="Polygon-API-1"></a><a class="docs-heading-anchor-permalink" href="#Polygon-API" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.Polygon"><a class="docstring-binding" href="#DeviceLayout.Polygons.Polygon"><code>DeviceLayout.Polygons.Polygon</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Polygon{T} &lt;: AbstractPolygon{T}
    p::Vector{Point{T}}
    Polygon(x) = new(x)
    Polygon(x::AbstractPolygon) = convert(Polygon{T}, x)
end</code></pre><p>Polygon defined by list of coordinates. The first point should not be repeated at the end (although this is true for the GDS format).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L95-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.Polygon-Union{Tuple{AbstractArray{Point{T}, 1}}, Tuple{T}} where T"><a class="docstring-binding" href="#DeviceLayout.Polygons.Polygon-Union{Tuple{AbstractArray{Point{T}, 1}}, Tuple{T}} where T"><code>DeviceLayout.Polygons.Polygon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Polygon{T}(parr::AbstractVector{Point{T}})</code></pre><p>Convenience constructor for a <code>Polygon{T}</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L118-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.Polygon-Tuple{Point, Point, Point, Vararg{Point}}"><a class="docstring-binding" href="#DeviceLayout.Polygons.Polygon-Tuple{Point, Point, Point, Vararg{Point}}"><code>DeviceLayout.Polygons.Polygon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Polygon(p0::Point, p1::Point, p2::Point, p3::Point...)</code></pre><p>Convenience constructor for a <code>Polygon{T}</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L111-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.perimeter"><a class="docstring-binding" href="#DeviceLayout.Polygons.perimeter"><code>DeviceLayout.Polygons.perimeter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">perimeter(poly::AbstractPolygon)</code></pre><p>The (Euclidean) perimeter of an <code>AbstractPolygon</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L495-L499">source</a></section><section><div><pre><code class="language-julia hljs">perimeter(poly::ClippedPolygon)</code></pre><p>The (Euclidean) perimeter of the outermost contour of a <code>ClippedPolygon</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L503-L507">source</a></section><section><div><pre><code class="language-julia hljs">perimeter(poly::Ellipse)</code></pre><p>Approximate (Euclidean) perimeter of an <code>Ellipse</code> using Ramanujan&#39;s approximation formula https://arxiv.org/pdf/math/0506384.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L512-L517">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.points"><a class="docstring-binding" href="#DeviceLayout.Polygons.points"><code>DeviceLayout.Polygons.points</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">points(x::Polygon)</code></pre><p>Return the array of <code>Point</code> objects defining the polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L385-L389">source</a></section><section><div><pre><code class="language-julia hljs">points{T}(x::Rectangle{T})</code></pre><p>Return the array of <code>Point</code> objects defining the rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L392-L396">source</a></section><section><div><pre><code class="language-julia hljs">points(x::ClippedPolygon)</code></pre><p>Return the array of <code>Point</code> objects that define the keyhole polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L399-L403">source</a></section><section><div><pre><code class="language-julia hljs">points(x::Clipper.PolyNode)</code></pre><p>Return the array of <code>Point</code> objects that make up the contour of the <code>PolyNode</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L406-L410">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.sweep_poly"><a class="docstring-binding" href="#DeviceLayout.Polygons.sweep_poly"><code>DeviceLayout.Polygons.sweep_poly</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sweep_poly(poly::Polygon, displacement::Point)</code></pre><p>Return a <code>Polygon</code> corresponding to the boundary formed by <code>poly</code> swept by <code>displacement</code>.</p><p>This is the result you would get by painting with a brush shaped like <code>poly</code> and moving it along a line by <code>displacement</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L864-L871">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.gridpoints_in_polygon"><a class="docstring-binding" href="#DeviceLayout.Polygons.gridpoints_in_polygon"><code>DeviceLayout.Polygons.gridpoints_in_polygon</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gridpoints_in_polygon(poly::AbstractArray{&lt;:AbstractPolygon},
    dx::Coordinate, dy::Coordinate; b=nothing)</code></pre><p>Return a <code>BitArray</code> for the gridpoints in <code>b</code> with <code>true</code> for gridpoints in <code>poly</code>.</p><p>Only grid points in the bounding box <code>b</code> will be considered; if <code>b</code> is <code>nothing</code>, then bounds(poly) is used. <code>dx</code> and <code>dy</code> are the distances between adjacent points on the rectangular grid. The grid points represented by the <code>BitArray</code> start from the lower left point <code>p0 = (m*dx, n*dy)</code> with <code>m</code> and <code>n</code> integers and <code>p0</code> lying in <code>b</code>.</p><p>All polygons should have the same orientation (clockwise or counterclockwise). A mix (for example to represent &quot;holes&quot;) may not give the desired behavior on polygon or hole edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L2050-L2064">source</a></section><section><div><pre><code class="language-julia hljs">gridpoints_in_polygon(poly::AbstractArray{&lt;:AbstractPolygon},
    grid_x::AbstractArray, grid_y::AbstractArray)</code></pre><p>Return a <code>BitArray</code> with <code>true</code> for points lying in some polygon in <code>poly</code>.</p><p>The <code>BitArray</code> values correspond to points <code>(x, y)</code> with <code>x ∈ grid_x</code>, <code>y ∈ grid_y</code>, starting from the lower left.</p><p>All polygons should have the same orientation (clockwise or counterclockwise). A mix (for example to represent &quot;holes&quot;) may not give the desired behavior on polygon or hole edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L2079-L2091">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Polygons.unfold"><a class="docstring-binding" href="#DeviceLayout.Polygons.unfold"><code>DeviceLayout.Polygons.unfold</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unfold(v::Vector{Point{T}}, direction; through_pt=nothing) where {T}
unfold(v::Vector{Point{T}}, p0, p1) where {T}</code></pre><p>Return a vector of twice the length of <code>v</code>, where the first half is <code>v</code> and the second half is <code>v</code> in reverse order and reflected about an axis.</p><p>This can be used to construct polygons that have a mirror symmetry. The symmetry axis can be defined in either of two ways: as a line with a given <code>direction</code> passing through point <code>through_pt</code> (defaults to origin), or by two points <code>p0</code>, <code>p1</code>. <code>direction</code> can be passed either as an angle or as a <code>Point</code> representing a vector.</p><p>As a trivial example, to draw a centered square:</p><pre><code class="language-julia hljs">uy = Point(0μm, 1μm) # could also be passed as 90°
pts = [Point(-1μm, -1μm), Point(-1μm, 1μm)]
square = Polygon(unfold(pts, uy))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/polygons.jl#L1642-L1661">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../entitystyles/">« Entity Styles</a><a class="docs-footer-nextpage" href="../coordinate_systems/">Coordinate Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 13:18">Wednesday 25 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
