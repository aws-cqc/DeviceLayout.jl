<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Routes · DeviceLayout.jl</title><meta name="title" content="Routes · DeviceLayout.jl"/><meta property="og:title" content="Routes · DeviceLayout.jl"/><meta property="twitter:title" content="Routes · DeviceLayout.jl"/><meta name="description" content="Documentation for DeviceLayout.jl."/><meta property="og:description" content="Documentation for DeviceLayout.jl."/><meta property="twitter:description" content="Documentation for DeviceLayout.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DeviceLayout.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Geometry-Level Layout</span><ul><li><a class="tocitem" href="../geometrylevel/">Overview</a></li><li><a class="tocitem" href="../units/">Units</a></li><li><a class="tocitem" href="../points/">Points</a></li><li><a class="tocitem" href="../geometry/">Geometry</a></li><li><a class="tocitem" href="../transformations/">Transformations</a></li><li><a class="tocitem" href="../entitystyles/">Entity Styles</a></li><li><a class="tocitem" href="../polygons/">Polygons</a></li><li><a class="tocitem" href="../coordinate_systems/">Coordinate Systems</a></li><li><a class="tocitem" href="../texts/">Texts</a></li><li><a class="tocitem" href="../paths/">Paths</a></li><li class="is-active"><a class="tocitem" href>Routes</a><ul class="internal"><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../shapes/">Shape library</a></li><li><a class="tocitem" href="../autofill/">Autofill</a></li><li><a class="tocitem" href="../render/">Rendering</a></li><li><a class="tocitem" href="../solidmodels/">Solid Models (3D Geometry)</a></li><li><a class="tocitem" href="../fileio/">File Formats</a></li><li><a class="tocitem" href="../faq/">Troubleshooting/FAQ</a></li></ul></li><li><span class="tocitem">Schematic-Driven Layout</span><ul><li><a class="tocitem" href="../schematicdriven/">Overview</a></li><li><a class="tocitem" href="../schematicdriven/components/">Components</a></li><li><a class="tocitem" href="../schematicdriven/hooks/">Hooks</a></li><li><a class="tocitem" href="../schematicdriven/schematics/">Schematics</a></li><li><a class="tocitem" href="../schematicdriven/technologies/">Technologies</a></li><li><a class="tocitem" href="../schematicdriven/targets/">Targets</a></li><li><a class="tocitem" href="../schematicdriven/solidmodels/">Solid Models</a></li><li><a class="tocitem" href="../schematicdriven/pdks/">PDKs</a></li><li><a class="tocitem" href="../schematicdriven/styleguide/">Style Guide</a></li><li><a class="tocitem" href="../schematicdriven/faq/">Troubleshooting/FAQ</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/examplepdk/">ExamplePDK</a></li><li><a class="tocitem" href="../examples/qpu17/">Quantum Processor</a></li><li><a class="tocitem" href="../examples/singletransmon/">Single-Transmon Simulation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Geometry-Level Layout</a></li><li class="is-active"><a href>Routes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Routes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/aws-cqc/DeviceLayout.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/main/docs/src/routes.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Routes"><a class="docs-heading-anchor" href="#Routes">Routes</a><a id="Routes-1"></a><a class="docs-heading-anchor-permalink" href="#Routes" title="Permalink"></a></h1><p>A <a href="#DeviceLayout.Paths.Route"><code>Paths.Route</code></a> implicitly defines a <code>Path</code> between two points, following a <a href="#DeviceLayout.Paths.RouteRule"><code>Paths.RouteRule</code></a>, with a specified start and end direction. It&#39;s a building block for &quot;interactive autorouting&quot;. For simple cases, it lets you define a path between two points without having to do any geometric calculations yourself. In more complicated cases, you can provide additional waypoint constraints to guide it.</p><p>To draw a <code>Path</code> from a <code>Route</code>, you can use <a href="../paths/#DeviceLayout.Paths.Path"><code>Path(r::Route, sty)</code></a>.</p><p>More often, you won&#39;t work directly with the <code>Route</code> type but will instead use <a href="#DeviceLayout.Paths.route!"><code>route!</code></a> to extend an existing path to an endpoint according to the rules you specify.</p><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.Route"><a class="docstring-binding" href="#DeviceLayout.Paths.Route"><code>DeviceLayout.Paths.Route</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Route{T&lt;:RouteRule, S&lt;:Coordinate}
Route(rule, startpoint::Point{S}, endpoint::Point, start_direction, end_direction; waypoints=Point{S}[], waydirs=[])
Route(rule, path0::Path, endpoint::Point, end_direction)</code></pre><p>A <code>Route</code> implicitly defines a <code>Path</code> between two points with given start and end directions.</p><p>Use <code>Path(r::Route, sty::Paths.Style)</code> to create the explicit path.</p><p>Contains a <code>RouteRule</code> to determine how the <code>Path</code> should be drawn.</p><p>May contain <code>waypoints</code> and <code>waydirs</code> that additionally constrain the route. The <code>RouteRule</code> determines how these are handled, by default routing waypoint-to-waypoint such that the path starts at <code>p0</code>, passes through each point in <code>waypoints</code> in order, and then ends at <code>p1</code>.</p><p>If <code>waydirs</code> is not <code>nothing</code>, it should have the same length as <code>waypoints</code>. If <code>waydirs</code> is provided and is not ignored by the <code>RouteRule</code> (check the specific rule documentation), then <code>waypoints[i]</code> will be reached with the path pointing along <code>waydirs[i]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L126-L144">source</a></section></details></article><h3 id="Route-rules"><a class="docs-heading-anchor" href="#Route-rules">Route rules</a><a id="Route-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Route-rules" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.RouteRule"><a class="docstring-binding" href="#DeviceLayout.Paths.RouteRule"><code>DeviceLayout.Paths.RouteRule</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type RouteRule end</code></pre><p>Controls how a <code>Route</code> is turned into a <code>Path</code>.</p><p>A <code>RouteRule</code> may contain parameters or be used only for dispatch. It should implement one of the following two methods:</p><pre><code class="nohighlight hljs">_route!(p::Path, p1::Point, α1, rule::MyRouteRule, sty, waypoints, waydirs)
_route_leg!(p::Path, next::Point, rule::MyRouteRule,
    sty::Paths.Style=Paths.contstyle1(p))</code></pre><p>It may also implement</p><pre><code class="nohighlight hljs">reconcile!(path::Path, endpoint::Point,
    end_direction, rule::RouteRule, waypoints, waydirs; initialize_waydirs)</code></pre><p>If only <code>_route_leg!</code> is implemented, then a <code>Path</code> drawn from <code>r::Route</code> with <code>MyRouteRule</code> will first call <code>reconcile!</code> to validate constraints and insert waypoints if necessary. (The default implementation of <code>reconcile!</code> does nothing.) The <code>Path</code> will then be routed waypoint-to-waypoint such that the path starts at <code>r.p0</code>, passes through each point in <code>r.waypoints</code> in order, and then ends at <code>r.p1</code>, ignoring <code>waydirs</code>. Alternatively, <code>_route!</code> can be implemented to use <code>r.waypoints</code> and/or <code>r.waydirs</code> all at once as desired.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.BSplineRouting"><a class="docstring-binding" href="#DeviceLayout.Paths.BSplineRouting"><code>DeviceLayout.Paths.BSplineRouting</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Base.@kwdef struct BSplineRouting &lt;: RouteRule
    endpoints_speed = 2500μm
    auto_speed = false
    endpoints_curvature = nothing
    auto_curvature = false
end</code></pre><p>Specifies rules for routing from one point to another using BSplines. Ignores <code>waydirs</code>.</p><p>Routes using this rule create a BSpline interpolation, similar to calling <a href="../paths/#DeviceLayout.Paths.bspline!"><code>Paths.bspline!</code></a> with the supplied keyword arguments.</p><p>The <code>endpoints_speed</code> is &quot;how fast&quot; the interpolation leaves and enters its endpoints. Higher speed means that the start and end directions are maintained over a longer distance.</p><p>If <code>auto_speed</code> is <code>true</code>, then <code>endpoints_speed</code> is ignored. Instead, the endpoint speeds are optimized to make curvature changes gradual as possible (minimizing the integrated square of the curvature derivative with respect to arclength).</p><p>If <code>endpoints_curvature</code> (dimensions of inverse length) is specified, then additional waypoints are placed so that the curvature at the endpoints is equal to <code>endpoints_curvature</code>.</p><p>If <code>auto_curvature</code> is specified, then <code>endpoints_curvature</code> is ignored. Instead, zero curvature is used. Note that <code>bspline!</code> in this case uses the ending curvature of the previous segment if it exists, but a <code>Route</code> does not have any previous segments.</p><p><code>endpoints_speed</code> and <code>endpoints_curvature</code> can also be provided as 2-element iterables to specify initial and final boundary conditions separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L73-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.StraightAnd90"><a class="docstring-binding" href="#DeviceLayout.Paths.StraightAnd90"><code>DeviceLayout.Paths.StraightAnd90</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Base.@kwdef struct StraightAnd90 &lt;: RouteRule
    min_bend_radius = 200μm
    max_bend_radius = Inf*μm
end
StraightAnd90(r) = StraightAnd90(min_bend_radius=r, max_bend_radius=r)</code></pre><p>Specifies rules for routing from one point to another using straight segments and 90° bends.</p><p>Can be used with no <code>waydirs</code> if each waypoint is reachable from the previous with a single turn and the endpoint is reachable with a single turn or two turns in opposite directions.</p><p>If <code>waydirs</code> are used, then any waypoint may be reachable with two turns in opposite directions if that satisfies the corresponding waydirection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L31-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.StraightAnd45"><a class="docstring-binding" href="#DeviceLayout.Paths.StraightAnd45"><code>DeviceLayout.Paths.StraightAnd45</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Base.@kwdef struct StraightAnd45 &lt;: RouteRule
    min_bend_radius = 200μm
    max_bend_radius = Inf*μm
end
StraightAnd45(r) = StraightAnd45(min_bend_radius=r, max_bend_radius=r)</code></pre><p>Specifies rules for routing from one point to another using using straight segments and 45° bends.</p><p>Can be used with no <code>waydirs</code> if each waypoint is reachable from the previous with a single turn and the endpoint is reachable with one or two turns.</p><p>If <code>waydirs</code> are used, then any waypoint may be reachable with two turns if that satisfies the corresponding waydirection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L52-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.CompoundRouteRule"><a class="docstring-binding" href="#DeviceLayout.Paths.CompoundRouteRule"><code>DeviceLayout.Paths.CompoundRouteRule</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompoundRouteRule &lt;: RouteRule
CompoundRouteRule(rules::Vector{RouteRule}, leg_length::Vector{Int}=ones(length(rules)))</code></pre><p>Specifies a sequence of rules for routing from one point to another, where <code>rules[i]</code> is used to route through the next <code>leg_length[i]</code> waypoints and/or endpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L113-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.SingleChannelRouting"><a class="docstring-binding" href="#DeviceLayout.Paths.SingleChannelRouting"><code>DeviceLayout.Paths.SingleChannelRouting</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct SingleChannelRouting{T &lt;: Coordinate} &lt;: AbstractChannelRouting
SingleChannelRouting(ch::RouteChannel, transition_rule::RouteRule, margin::T)
SingleChannelRouting(ch::RouteChannel, transition_rules, margins)</code></pre><p>A <code>RouteRule</code> for guiding routed paths along tracks in a <a href="#DeviceLayout.Paths.RouteChannel"><code>Paths.RouteChannel</code></a>.</p><p><strong>Tracks</strong></p><p>&quot;Tracks&quot; are offsets of the channel&#39;s path, with equal spacing between each other and the extents of the channel&#39;s trace width. Tracks are ordered from left to right when facing along the channel. For example, for a channel directed along the positive x axis, track 1 is the top track (most positive offset), while the highest track index is its bottom track.</p><p>The user manually assigns tracks to paths that will be routed with <code>rule::SingleChannelRouting</code> using <code>Paths.set_track!(rule, path, track_idx)</code> for each path, prior to calling <code>route!(path, ...)</code>. Because the track offset depends on the total number of tracks, and the number of tracks is determined by the maximum track index of any path added to <code>rule</code>, all paths should be assigned tracks before any <code>route!</code> call.</p><p>If used for schematic routing, the track is supplied as a keyword argument, defaulting to a new track added at the bottom of the channel: <code>route!(g::SchematicGraph, rule, ...; track=num_tracks(rule)+1)</code>.</p><p><strong>Routing</strong></p><p>A path routed from <code>p0</code> to <code>p1</code> using this rule will enter the channel at the channel&#39;s closest point to <code>p0</code> and exit at the closest point to <code>p1</code> if <code>margin</code> is zero. For nonzero <code>margin</code>, the entry and exit points are each shifted towards the other along the channel by <code>margin</code>, allowing more space for the transitions into and out of the channel.</p><p>The middle &quot;tracked&quot; section is offset from the channel&#39;s center line according to the path&#39;s track, the maximum track assigned to any path by the rule, and the channel width.</p><p>The path is routed from <code>p0</code> to the tracked section and from the tracked section to <code>p1</code> using <code>transition_rule</code>.</p><p>Transition rules and margins can also be supplied as tuples to the constructor to allow different parameters for entry and exit transitions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/channels.jl#L207-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.RouteChannel"><a class="docstring-binding" href="#DeviceLayout.Paths.RouteChannel"><code>DeviceLayout.Paths.RouteChannel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RouteChannel{T} &lt;: AbstractComponent{T}
RouteChannel(pa::Path)</code></pre><p>A channel that routes can be guided through along parallel tracks.</p><p>Used in <code>route!</code> with <a href="#DeviceLayout.Paths.SingleChannelRouting"><code>Paths.SingleChannelRouting</code></a>.</p><p>The <code>Path</code> used to construct a <code>RouteChannel</code> should use <code>Trace</code> styles only.</p><p>A <code>RouteChannel</code> is an <code>AbstractComponent</code> with the same hooks as its <code>Path</code> and an empty geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/channels.jl#L1-L13">source</a></section></details></article><h3 id="Route-drawing"><a class="docs-heading-anchor" href="#Route-drawing">Route drawing</a><a id="Route-drawing-1"></a><a class="docs-heading-anchor-permalink" href="#Route-drawing" title="Permalink"></a></h3><p>Calling <code>Path(r::Route, sty::Style)</code> creates a new <code>Path</code> at <code>p0(r)</code>, then extends it to <code>p1(r)</code> using <code>route!</code>. The default implementation of <code>route!</code>, for a generic <code>RouteRule</code>, first calls <code>reconcile!</code> to validate and modify waypoints as necessary. It then calls <code>_route!</code> to draw the path, which by default calls <code>_route_leg!</code> to each waypoint in order. (A &quot;leg&quot; is an informal abstraction describing the &quot;unit&quot; that the <code>RouteRule</code> works with, which may be more than one <code>Paths.Segment</code>. For example, each leg in <code>StraightAnd90</code> routing has a single 90-degree bend with up to one straight segment on either side, or a single straight segment if no bend is necessary.)</p><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.Path-Tuple{Route, DeviceLayout.Paths.Style}"><a class="docstring-binding" href="#DeviceLayout.Paths.Path-Tuple{Route, DeviceLayout.Paths.Style}"><code>DeviceLayout.Paths.Path</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Path(r::Route, sty)</code></pre><p>The explicit <code>Path</code> defined by <code>r</code>, with style <code>sty</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L413-L417">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.route!"><a class="docstring-binding" href="#DeviceLayout.Paths.route!"><code>DeviceLayout.Paths.route!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">function route!(path::Path{S}, p_end::Point, α_end, rule::RouteRule, sty=Paths.contstyle1(path);
                waypoints=Point{S}[], waydirs=Vector{typeof(1.0°)}(undef, length(waypoints)))) where {S}</code></pre><p>Extend <code>path</code> to <code>p_end</code> with arrival angle <code>α_end</code> according to <code>RouteRule</code>. The default implementation is</p><pre><code class="nohighlight hljs">reconcile!(path, p_end, α_end, rule, waypoints, waydirs)
_route!(path, p_end, α_end, rule, sty, waypoints, waydirs)</code></pre><p>followed by checking that the endpoint was successfully reached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L424-L437">source</a></section><section><div><pre><code class="language-julia hljs">route!(g::SchematicGraph, rule::RouteRule,
    nodehook1::Pair{ComponentNode,Symbol}, nodehook2::Pair{ComponentNode,Symbol},
    sty, meta;
    waypoints=[], waydirs=[], global_waypoints=false,
    name=uniquename(&quot;r_$(component(nodehook1.first).name)_$(component(nodehook2.first).name)&quot;),
    kwargs...)
route!(g::SchematicGraph, rule::RouteRule, node1::ComponentNode, nodehook2::Pair{ComponentNode,Symbol}, sty, meta; kwargs...)
route!(g::SchematicGraph, rule::RouteRule, nodehook1::Pair{ComponentNode,Symbol}, node2::ComponentNode, sty, meta; kwargs...)
route!(g::SchematicGraph, rule::RouteRule, node1::ComponentNode, node2::ComponentNode, sty, meta; kwargs...)</code></pre><p>Creates a <code>RouteComponent</code> with given style <code>sty</code> and metadata <code>meta</code>, and fuses it between the specified nodes and hooks in <code>g</code>.</p><p>Returns the resulting <code>ComponentNode</code> in <code>g</code>.</p><p>Example usage: <code>route!(g, BSplineRouting(), zline_node=&gt;:feedline, z_launcher_node=&gt;:line, Paths.CPW(10μm, 6μm), GDSMeta(1, 2))</code></p><p>If one or both hook symbols are not specified, then <code>matching_hook</code> or <code>matching_hooks</code> will be used to attempt to automatically find the correct hook or hooks.</p><p>The route will have start and endpoints at the origin until a method like <code>plan!</code> is called. <code>waypoints</code> and <code>waydirs</code> are in component-local coordinates (unless <code>global_waypoints</code> is <code>true</code>), and <code>rule</code> determines how they will be used.</p><p>Additional keyword arguments will become vertex properties for the <code>RouteComponent</code>&#39;s node.</p><p><code>name</code> should be unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/schematics/routes.jl#L152-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.reconcile!-Tuple{Path, Point, Any, DeviceLayout.Paths.RouteRule, Any, Any}"><a class="docstring-binding" href="#DeviceLayout.Paths.reconcile!-Tuple{Path, Point, Any, DeviceLayout.Paths.RouteRule, Any, Any}"><code>DeviceLayout.Paths.reconcile!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reconcile!(path::Path, endpoint::Point, end_direction, rule::RouteRule, waypoints, waydirs;
    initialize_waydirs = false)</code></pre><p>Ensure that <code>path</code> can be routed to <code>endpoint</code> at <code>end_direction</code> using <code>rule, waypoints, waydirs</code>, or log an error.</p><p>Does nothing for a generic <code>RouteRule</code>. Subtypes of <code>RouteRule</code> may implement specialized methods to do their own validation when <code>route!</code> is called.</p><p>May insert inferred constraints to <code>waypoints</code> and <code>waydirs</code> to allow the path to be drawn leg-by-leg. For example, <code>reconcile!</code> with <code>rule::StraightAnd90</code>, no waypoints, and <code>α1(path) == end_direction</code> will insert a waypoint halfway between <code>p1(path)</code> and <code>endpoint</code>, allowing two successive <code>StraightAnd90</code> legs with opposite bends.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L203-L216">source</a></section></details></article><h3 id="Route-inspection"><a class="docs-heading-anchor" href="#Route-inspection">Route inspection</a><a id="Route-inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Route-inspection" title="Permalink"></a></h3><p>A <code>Route</code> supports endpoint inspection much like a <code>Path</code> does:</p><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.p0-Tuple{Route}"><a class="docstring-binding" href="#DeviceLayout.Paths.p0-Tuple{Route}"><code>DeviceLayout.Paths.p0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">p0(s::Segment{T}) where {T}</code></pre><p>Return the first point in a segment (calculated).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/paths.jl#L301-L305">source</a></section><section><div><pre><code class="language-julia hljs">p0(r::Route)</code></pre><p>First point of a route, returns <code>r.p0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L178-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.α0-Tuple{Route}"><a class="docstring-binding" href="#DeviceLayout.Paths.α0-Tuple{Route}"><code>DeviceLayout.Paths.α0</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">α0(s::Segment)</code></pre><p>Return the first angle in a segment (calculated).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/paths.jl#L315-L319">source</a></section><section><div><pre><code class="language-julia hljs">α0(r::Route)</code></pre><p>First angle of a route, returns <code>r.α0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L190-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.p1-Tuple{Route}"><a class="docstring-binding" href="#DeviceLayout.Paths.p1-Tuple{Route}"><code>DeviceLayout.Paths.p1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">p1(s::Segment{T}) where {T}</code></pre><p>Return the last point in a segment (calculated).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/paths.jl#L308-L312">source</a></section><section><div><pre><code class="language-julia hljs">p1(r::Route)</code></pre><p>Last point of a route, returns <code>r.p1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L184-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DeviceLayout.Paths.α1-Tuple{Route}"><a class="docstring-binding" href="#DeviceLayout.Paths.α1-Tuple{Route}"><code>DeviceLayout.Paths.α1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">α1(r::Route)</code></pre><p>Last angle of a route, returns <code>r.α1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aws-cqc/DeviceLayout.jl/blob/2b8e4d869406d4545d97ffb7d0dd1983dbdb4430/src/paths/routes.jl#L196-L200">source</a></section></details></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><h3 id="Channel-routing"><a class="docs-heading-anchor" href="#Channel-routing">Channel routing</a><a id="Channel-routing-1"></a><a class="docs-heading-anchor-permalink" href="#Channel-routing" title="Permalink"></a></h3><p><code>RouteChannels</code> offer a way to run routes in parallel, with routes joining or leaving a channel at different points. Using <a href="#DeviceLayout.Paths.SingleChannelRouting"><code>Paths.SingleChannelRouting</code></a>, we can set the &quot;track&quot; (a curve offset from the channel centerline) for each route to follow through the channel, as well as some rules for joining and leaving the channel from route start and end points. Here&#39;s a basic example with a straight channel:</p><pre><code class="language-julia hljs">using DeviceLayout, .PreferredUnits, FileIO
import DeviceLayout.Graphics: inch
# Define start and end points for various routes
p0s = [
    Point(100.0, 200.0)μm,   # Enter and exit from top
    Point(50.0, 150)μm,      # Enter from top, exit from right
    Point(-100.0, -100.0)μm, # Enter from lower left, exit from right
    Point(600.0, -150)μm,    # Enter from bottom, exit from right
    Point(100.0, -200.0)μm   # Enter and exit from bottom
]

p1s = [
    Point(900.0, 200.0)μm,
    Point(1100.0, 150.0)μm,
    Point(1200.0, 50.0)μm,
    Point(1100.0, -150.0)μm,
    Point(400.0, -200.0)μm
]

# Create channel
channel_path = Path()
straight!(channel_path, 1mm, Paths.Trace(0.1mm))
channel = Paths.RouteChannel(channel_path)
# Initialize paths
paths = [Path(p) for p in p0s]
# Define route rule
transition_rule = Paths.StraightAnd90(25μm) # Manhattan with 25μm bend radius
margin = 50.0μm # Room for bends between endpoints and channel
rule = Paths.SingleChannelRouting(channel, transition_rule, margin)
# Set tracks
tracks = [1, 2, 3, 4, 4] # Last two share a track
setindex!.(Ref(rule.segment_tracks), tracks, paths)
# Draw routes
for (pa, p1) in zip(paths, p1s)
    route!(pa, p1, 0.0°, rule, Paths.Trace(2μm))
end
c = Cell(&quot;test&quot;)
render!.(c, paths, GDSMeta())
render!(c, channel_path, GDSMeta(1))
save(&quot;straight_channel.svg&quot;, flatten(c); width=6inch, height=2inch);</code></pre><img src="../straight_channel.svg" style="width:6in;"/><p>We can also have curved channels, like the <code>BSpline</code>-based example below. For the transition rule, <code>StraightAnd90</code> would no longer work for the paths that join the channel at an angle, so we use <code>BSplineRouting</code> instead. We also enable <code>auto_speed</code> and <code>auto_curvature</code> on that rule to help smooth out the B-splines and maintain continuous curvature.</p><pre><code class="language-julia hljs"># Create BSpline channel
channel_path = Path()
bspline!(
    channel_path,
    [Point(0.5, 0.5)mm, Point(1.0mm, 0.0μm)],
    0°,
    Paths.Trace(0.1mm),
    auto_speed=true,
    auto_curvature=true
)
channel = Paths.RouteChannel(channel_path)
# Initialize paths
paths = [Path(p) for p in p0s]
# Define route rule
transition_rule = Paths.BSplineRouting(auto_speed=true, auto_curvature=true)
margin = 50.0μm
rule = Paths.SingleChannelRouting(channel, transition_rule, margin)
# Set tracks
tracks = [1, 2, 3, 4, 4] # Last two share a track
setindex!.(Ref(rule.segment_tracks), tracks, paths)
# Draw routes
for (pa, p1) in zip(paths, p1s)
    route!(pa, p1, 0.0°, rule, Paths.Trace(2μm))
end
c = Cell(&quot;test&quot;)
render!.(c, paths, GDSMeta())
render!(c, channel_path, GDSMeta(1))
save(&quot;bspline_channel.svg&quot;, flatten(c); width=6inch, height=4inch);</code></pre><img src="../bspline_channel.svg" style="width:6in;"/><p>Channels can also have variable width, like the example below using the <code>TaperTrace</code> style on a compound segment consisting of four turns.</p><pre><code class="language-julia hljs"># Create tapered, composite channel
channel_path = Path()
turn!(channel_path, 90°, 0.25mm, Paths.Trace(0.1mm))
turn!(channel_path, -90°, 0.25mm)
turn!(channel_path, -90°, 0.25mm)
turn!(channel_path, 90°, 0.25mm)
simplify!(channel_path)
setstyle!(channel_path[1], Paths.TaperTrace(0.1mm, 0.05mm))
channel = Paths.RouteChannel(channel_path)
# Initialize paths
paths = [Path(p) for p in p0s]
# Define route rule
transition_rule = Paths.BSplineRouting(auto_speed=true, auto_curvature=true)
margin = 50.0μm
rule = Paths.SingleChannelRouting(channel, transition_rule, margin)
# Set tracks
tracks = [1, 2, 3, 4, 4] # Last two share a track
setindex!.(Ref(rule.segment_tracks), tracks, paths)
# Draw routes
for (pa, p1) in zip(paths, p1s)
    route!(pa, p1, 0.0°, rule, Paths.Trace(2μm))
end
c = Cell(&quot;test&quot;)
render!.(c, paths, GDSMeta())
render!(c, channel_path, GDSMeta(1))
save(&quot;compound_channel.svg&quot;, flatten(c); width=6inch, height=4inch);</code></pre><img src="../compound_channel.svg" style="width:6in;"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../paths/">« Paths</a><a class="docs-footer-nextpage" href="../shapes/">Shape library »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Wednesday 25 February 2026 13:18">Wednesday 25 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
