# [Components and Hooks](@id components-concept)

Components are the reusable building blocks of schematic-driven design.

See [API Reference: Components](@ref api-components) and the [Building a Component](../tutorials/building_a_component.md) tutorial.

## Anatomy of a Component

Every component has:

1. **Type**: Defined with `@compdef`
2. **Parameters**: Configurable values with defaults
3. **Geometry**: Shapes generated by `_geometry!`
4. **Hooks**: Connection points defined by `hooks`

Example:

```@example
@compdef struct MyComponent <: AbstractComponent{typeof(1.0nm)}
    name = "my_component"      # Parameters with defaults
    width = 100μm
    height = 50μm
end

function _geometry!(cs, comp::MyComponent)
    place!(cs, Rectangle(comp.width, comp.height), :layer)
end

function hooks(comp::MyComponent)
    return (; p0 = PointHook(Point(0nm, 25μm), 180°))
end

comp = MyComp(height=100μm)
@show comp
@show parameters(comp)
@show hooks(comp)
@show geometry(comp)
```

`@compdef` creates the keyword constructor (like `Base.@kwdef` does) as well as a `default_parameters` method. Validation or reconciling of parameters should be done in an inner constructor. At least one
inner constructor should accept arguments in the
same form as the default inner constructor (i.e. one positional argument per field) in
order to function correctly with the keyword outer constructor.

`@compdef` also creates a private field for geometry, which is computed the first time it is needed and stored thereafter.

Because `AbstractComponent{T}` is a subtype of `GeometryStructure{T}`, components support the [Structure API](@ref api-geometrystructure) as well as general geometry methods like `bounds`. Most of those methods are not implemented by the component but are instead forwarded to the `CoordinateSystem` containing the component's geometry (that is, `bounds(mycomponent) = bounds(geometry(mycomponent))`). One exception is `name`: A component's name is not necessarily unique, but the name of `geometry(component)` is set using `uniquename(name(component))`.

An `AbstractComponent` may override some `GeometryStructure` methods like `footprint` and `halo` when customization or efficient computation is required (see [Concepts: Autofill](@ref concept-autofill)).

The methods [`check_rotation`](@ref) and [`allowed_rotation_angles`](@ref) can be implemented to enforce a requirement for the orientation of the component in the global coordinate system (checked by `check!(schematic)` by default). Other schematic design rules can be implemented with a similar pattern: a "trait" method that says that the rule applies, and a second method used to evaluate the rule.

Finally, an `AbstractComponent` may define [`matching_hooks`](@ref) methods to specify default hooks for fusion with other components in a schematic. Methods for both argument orders in `matching_hooks` should generally be defined. Although
`SchematicGraph`s are undirected, certain components may treat the different argument orders
differently. For example, `matching_hooks(::Path, <:AbstractComponent)` will attach the
second argument to the endpoint hook `:p1` on the `Path`, while the reverse order
will attach the start point hook `:p0` to the first argument.

## Hooks

Hooks define where and how components connect.

### PointHook

```julia
PointHook(position, direction)
```

- **position**: `Point` in local coordinates
- **direction**: Angle pointing *into* the component

### Hook Convention

When two hooks fuse:
- Positions coincide
- Directions oppose (differ by 180°)

```
Component A:  →  ← :Component B
              ↑
          fuse point
```

## Component Hierarchy

```
AbstractComponent
├── Basic components (define _geometry!, hooks)
├── CompositeComponent (define graph, map_hooks)
└── Path (special component with :p0, :p1 hooks)
```

## Composite Components

Build components from other components:

```julia
@compdef struct MyComposite <: CompositeComponent{typeof(1.0nm)}
    ...
end

function graph(comp::MyComposite)
    g = SchematicGraph(comp.name)
    # Add and connect subcomponents
    return g
end

function map_hooks(comp::MyComposite)
    return Dict(:external => (node_id, :internal))
end
```

## See Also

- [How to Define Hooks](../how_to/components/define_hooks.md)
- [How to Create Composite Components](../how_to/components/create_composite.md)
